<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>行为型-策略模式 - Xiangao2018 的个人博客</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Xiangao2018 的个人博客</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">设计模式</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" class="dropdown-item">创建型-简单工厂、工厂方法、抽象工厂</a>
</li>
                                    
<li>
    <a href="../%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="dropdown-item">结构型-装饰器设计模式</a>
</li>
                                    
<li>
    <a href="../%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="dropdown-item">结构型-适配器模式</a>
</li>
                                    
<li>
    <a href="../%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" class="dropdown-item">行为型-命令模式</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">行为型-策略模式</a>
</li>
                                    
<li>
    <a href="../%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="dropdown-item">行为型-观察者模式</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#_1" class="nav-link">策略模式</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">需求一：设计鸭子模型</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_4" class="nav-link">需求二：让鸭子能飞吧</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_5" class="nav-link">整合鸭子行为</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_6" class="nav-link">策略模式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="_1">策略模式</h1>
<p>标签（空格分隔）： 设计模式 Swift</p>
<hr />
<div class="toc">
<ul>
<li><a href="#_1">策略模式</a><ul>
<li><a href="#_2">需求一：设计鸭子模型</a><ul>
<li><a href="#_3">延伸思考：鸭子类型能否使用接口或者协议来表示?</a></li>
</ul>
</li>
<li><a href="#_4">需求二：让鸭子能飞吧</a><ul>
<li><a href="#1-fly-quack">延伸思考1：能否将 Fly 和 Quack 变化部分接口编程</a></li>
<li><a href="#2-vs">延伸思考2：继承 VS 组合</a></li>
</ul>
</li>
<li><a href="#_5">整合鸭子行为</a></li>
<li><a href="#_6">策略模式</a></li>
</ul>
</li>
</ul>
</div>
<p>面向对象的三大特性：封装、继承和多态，这三大特性其实为了方便代码的<strong>复用</strong>与<strong>管理</strong>。</p>
<h2 id="_2">需求一：设计鸭子模型</h2>
<p><strong>需求：</strong>设计一款简单的鸭子游戏，里面鸭子可以进行嘎嘎叫（quack）以及游泳（swim），还需要一个能展示鸭子外观（display）的方法。</p>
<p>为了代码的复用（quack 以及 swim），设计一个超类 Duck，子类继承于 Duck，但是子类各自实现不同的部分（display）,标准的 OO 编程。</p>
<pre><code class="language-swift">class Duck {
    func quack() { debugPrint(&quot;嘎嘎&quot;) }
    func swim() { debugPrint(&quot;游泳&quot;) }
    func display() { fatalError(&quot; subclass implement &quot;) }
}

class MallarDuck: Duck {
    override func display() { debugPrint( &quot;Mallar Duck display&quot; ) }
}

class RedHeadDuck: Duck {
    override func display() { debugPrint( &quot;Red Head Duck display&quot; ) }
}

</code></pre>
<h3 id="_3">延伸思考：鸭子类型能否使用接口或者协议来表示?</h3>
<pre><code>protocol DuckRepresentable {
    func quack()
    func swim()
    func display()
}

extension DuckRepresentable {
    func quack() { debugPrint(&quot;嘎嘎&quot;) }
    func swim() { debugPrint(&quot;游泳&quot;) }
}


class MallarDuck: DuckRepresentable {
    func display() { debugPrint( &quot;Mallar Duck display&quot; ) }
}

class RedHeadDuck: DuckRepresentable {
    func display() { debugPrint( &quot;Red Head Duck display&quot; ) }
}
</code></pre>
<p>得益于 Swift 协议扩展默认实现，可以复用 <code>quack</code> 以及 <code>swim</code> 代码。但在其他语言中（例如 Java），就需要为每个遵循 <code>DuckRepresentable</code> 接口的类型实现 <code>quack</code>、<code>swim</code> 以及 <code>display</code> 方法，代码得不到复用。</p>
<hr />
<h2 id="_4">需求二：让鸭子能飞吧</h2>
<p><strong>需求：</strong> 项目迭代，需要给鸭子添加飞行的能力。同时需要增加一种橡皮鸭（RubberDuck），这种鸭子发出吱吱叫声，但是不能飞。</p>
<p>需求需要鸭子会飞，因此在父类 Duck 中 <code>fly()</code> 方法即可。橡皮鸭重写 <code>quack()</code> 以及 <code>fly()</code></p>
<pre><code class="language-swift">class Duck {
    func quack() { debugPrint(&quot;嘎嘎&quot;) }
    func swim() { debugPrint(&quot;游泳&quot;) }
    func display() { fatalError(&quot; subclass implement &quot;) }
    func fly() { debugPrint( &quot;飞行&quot; ) }
}

class MallarDuck: Duck {
    override func display() { debugPrint( &quot;Mallar Duck display&quot; ) }
}

class RedHeadDuck: Duck {
    override func display() { debugPrint( &quot;Red Head Duck display&quot; ) }
}

class RubberDuck: Duck {
    override func quack() { debugPrint(&quot;吱吱&quot;) }
    override func display() { debugPrint( &quot;Rubber Duck display&quot; ) }
    override func fly() { /* 不能飞行 */ }
}

</code></pre>
<p>Great！完成了需求！下面来分析下这里面可能面临的问题：</p>
<ol>
<li>每增加一种行为需要检查所有的鸭子是否符合该行为;</li>
<li>与父类行为不一致的代码无法进行复用;</li>
<li>无法在运行时改变对应的行为;</li>
</ol>
<p>采用继承的方式，都需要关注子类是否能够继承父类所有的行为，每添加一种行为，也必须检查<strong>所有</strong>子类是否符合这种行为，如果不符合，大多就是重写改行为（例如 fly 啥也不做）。但在理想情况下，<strong>每一个子类对象仅仅需要关注只能能支持的行为，而不需要考虑自己不支持的行为</strong>。当然可以让系统默认啥都不干，让子类进行关注自己的行为，但这同样引出了问题 3；如果多种鸭子有相同的行为且与父类默认行为不一致，此部分的代码就无法复用了。
问题 4 很明显，目前的类型无法在运行时动态改变。</p>
<h3 id="1-fly-quack">延伸思考1：能否将 Fly 和 Quack 变化部分接口编程</h3>
<p>每新增一种行为(例如 fly), 我们需要检查所有的子类是否符合该行为，那么能否用接口 flyable 接口，让拥有改行为的 Duck 遵循接口？</p>
<pre><code>protocol Flyable {
    func fly()
}

protocol Quackable {
    func quack();
}

class Duck {
    func swim() { debugPrint(&quot;游泳&quot;) }
    func display() { fatalError(&quot; subclass implement &quot;) }
}

class MallarDuck: Duck, Flyable, Quackable {
    override func display() { debugPrint( &quot;Mallar Duck display&quot; ) }

    func quack() { debugPrint(&quot;嘎嘎&quot;) }
    func fly() { debugPrint( &quot;Mallar Duck fly&quot; ) }
}

class RedHeadDuck: Duck,Flyable, Quackable {
    override func display() { debugPrint( &quot;Red Head Duck display&quot; ) }

    func quack() { debugPrint(&quot;嘎嘎&quot;) }
    func fly() { debugPrint( &quot;Red Head Duck fly&quot; ) }
}

class RubberDuck: Duck, Quackable{
    override func display() { debugPrint( &quot;Rubber Duck display&quot; ) }    
    func quack() { debugPrint(&quot;吱吱&quot;) }
}

</code></pre>
<p>面向接口编程，虽然能解决掉问题 1, 但是问题 2 和 问题 3 依旧存在。</p>
<h3 id="2-vs">延伸思考2：继承 VS 组合</h3>
<p>继承是在<strong>编译期间</strong>确定的<strong>强耦合</strong>的结构关系；
组合是在<strong>运行期间</strong>确定的<strong>松耦合关系</strong>，组合能够在运行时动态改变该行为。</p>
<p>同时在大多数语言中支持遵循多接口，但不支持遵循多继承（笔者目前就知道 C++支持多继承）。</p>
<hr />
<h2 id="_5">整合鸭子行为</h2>
<p>为了代码行为复用，我们将变化的部分（fly 以及 quack）提取出来，为了动态改变对应的行为，采用接口编程动态的改变行为。</p>
<pre><code>protocol FlyBehavior {
    func fly()
}

class FlyNoWay: FlyBehavior {
    func fly() { debugPrint( &quot;无法飞行&quot;) }
}

class FlyWithWings: FlyBehavior {
    func fly() { debugPrint( &quot;可飞行 &quot;) }
}

protocol QuackBehavior {
    func quack()
}

class MuteQuack: QuackBehavior {
    func quack() { debugPrint( &quot;无法叫&quot; ) }
}

class Squeak: QuackBehavior {
    func quack() { debugPrint( &quot;嘎嘎&quot; ) }
}

class Creak: QuackBehavior {
    func quack() { debugPrint( &quot;吱吱&quot; ) }
}

class Duck {

    var flyBehavior: FlyBehavior?
    var quackBehavior: QuackBehavior?

    func swim() { debugPrint(&quot;游泳&quot;) }
    func display() { }

    func makeFly() { flyBehavior?.fly() }
    func makeQuack() { quackBehavior?.quack() }
}

class MallarDuck: Duck {

    override init() {
        super.init()

        self.flyBehavior = FlyWithWings()
        self.quackBehavior = Squeak()
    }

    override func display() { debugPrint( &quot;Mallar Duck display&quot; ) }
}

class RedHeadDuck: Duck {

    override init() {
        super.init()

        self.flyBehavior = FlyWithWings()
        self.quackBehavior = Squeak()
    }

    override func display() { debugPrint( &quot;Red Head Duck display&quot; ) }
}

class RubberDuck: Duck {
    override init() {
        super.init()

        self.flyBehavior = FlyNoWay()
        self.quackBehavior = Creak()
    }

    // 动态改变行为
    func makeWing() {
        self.flyBehavior = FlyWithWings()
    }

    // 动态改变行为
    func makeBroken() {
        self.quackBehavior = MuteQuack()
    }

    override func display() { debugPrint( &quot;Rubber Duck display&quot; ) }

}


</code></pre>
<p>这里将 FlyBehavior 和 QuackBehavior 设计为接口，并未设计为一个类。这是因为接口更加灵活，设计为具体类后，以后想改变该类型需要强绑定为该类的子类，缺少灵活性。<strong>尽量针对接口编程，而不是针对实现编程</strong></p>
<p>采用组合的方式将 FlyBehavior 和 QuackBehavior 联系起来，在运行时动态的去确定具体的类型。</p>
<h2 id="_6">策略模式</h2>
<p><strong>定义：</strong> 策略模式就是讲算法簇封装起来，然后让他们可以相互替换，并且可以再不同的场景中进行代码的复用。</p>
<p>在本例中，遵循 <code>FlyBehavior</code> 和 <code>QuackBehavior</code> 类似于定义的算法，然后在 RubberDuck 的 <code>makeWing</code> 和 <code>makeBreaken</code> 中动态的改变了 <code>flyBehavior</code> 和 <code>quackBehavior</code> 的行为。</p>
<p>上面的例子取自与 《Head First 设计模式》 第一章，主要将的就是策略模式。主要介绍了三大原则: </p>
<ul>
<li>封装变化</li>
<li>多用组合，少用继承</li>
<li>针对接口编程，不针对实现编程</li>
</ul></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
